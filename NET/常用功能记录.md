## BackgroundService
该类是一个抽象基类，用于简化后台任务的实现。它提供了一种方法来覆盖：BackgroundService
ExecuteAsync（CancellationToken stoppingToken）：包含后台任务的逻辑，并运行到应用程序关闭为止。BackgroundService 实现示例：
启用类：
```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =>
                       {
                           services.AddHostedService<TimedBackgroundService>(); 
                       })
    .Build();

await host.RunAsync();
```
服务类：
```csharp
using System.Threading.Tasks;

namespace ConsoleApp1
{
    public class TimedBackgroundService : BackgroundService
    {
        protected override Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (true)
            {
                Console.WriteLine("222Timed Background Service running.");
            }
        }
    }
}
```


## RabbitMQ
### 点对点（也称为工作队列模式）
生产端
```csharp
using RabbitMQ.Client;
using System.Text;

var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    //声明队列，不声明，如果队列不存在会报错
    channel.QueueDeclare(
        // 队列名称
        queue: "hello",
        // 持久化配置，队列是否能够在 broker 重启后存活
        durable: false,
        // 连接关闭时被删除该队列
        exclusive: false,
        // 当最后一个消费者(如果有的话)退订时，是否应该自动删除这个队列
        autoDelete: false,
        // 额外的参数配置
        arguments: null
     );

    channel.BasicPublish(
        // 使用默认交换器
        exchange: string.Empty,
        // 推送到哪个队列中
        routingKey: "hello",
        // 队列属性
        basicProperties: null,
        // 要发送的消息需要先转换为 byte[]
        body: Encoding.UTF8.GetBytes("测试")
    ); 
}
```
消费端：
```csharp
using RabbitMQ.Client.Events;
using RabbitMQ.Client;
using System.Text;

var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    //声明队列，不声明，如果队列不存在会报错
    channel.QueueDeclare(
        // 队列名称
        queue: "hello",
        // 持久化配置，队列是否能够在 broker 重启后存活
        durable: false,
        // 连接关闭时被删除该队列
        exclusive: false,
        // 当最后一个消费者(如果有的话)退订时，是否应该自动删除这个队列
        autoDelete: false,
        // 额外的参数配置
        arguments: null
     );

    var consumer = new EventingBasicConsumer(channel);
    consumer.Received += (model, ea) => {
        var body = ea.Body.ToArray();
        var message = Encoding.UTF8.GetString(body);
        Console.WriteLine(" [x] Received {0}", message);
    };

    channel.BasicConsume(
        queue: "hello",
        autoAck: true,
        consumer: consumer
    ); 
}
```

### 发布/订阅（一对多）
在RabbitMQ中，发布/订阅（一对多）模式通常涉及一个或多个生产者发送消息到一个交换器（Exchange），而多个消费者则从绑定到该交换器的队列中接收消息。以下是一个简单的发布/订阅模式的C#示例代码，包括生产者和消费者。
生产端
```csharp
using RabbitMQ.Client;
using System.Text;


var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 声明一个名为"logs"的fanout类型的交换器  
    channel.ExchangeDeclare(
        // 交换器
        exchange: "logs", 
        // 类型
        type: "fanout",
        // 持久化配置，队列是否能够在 broker 重启后存活
        durable: false, 
        // 当最后一个消费者(如果有的话)退订时，是否应该自动删除这个队列
        autoDelete: false,
        // 额外的参数配置
        arguments: null
     ); 

    string message = "Hello World!";
    var body = Encoding.UTF8.GetBytes(message);

    // 发送消息到交换器，没有指定路由键，因为fanout类型会广播到所有队列  
    channel.BasicPublish(exchange: "logs",
                         routingKey: "",
                         basicProperties: null,
                         body: body);
    Console.WriteLine(" [x] Sent {0}", message);
}
```
消费端：
```csharp
using RabbitMQ.Client.Events;
using RabbitMQ.Client;
using System.Text;


var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 声明一个队列  
    var queueName = channel.QueueDeclare().QueueName;
     
    // 声明一个名为"logs"的fanout类型的交换器  
    channel.ExchangeDeclare(
        // 交换器
        exchange: "logs",
        // 类型
        type: "fanout",
        // 持久化配置，队列是否能够在 broker 重启后存活
        durable: false,
        // 当最后一个消费者(如果有的话)退订时，是否应该自动删除这个队列
        autoDelete: false,
        // 额外的参数配置
        arguments: null
     );

    // 将队列绑定到交换器上，因为没有指定路由键，所以所有发送到"logs"交换器的消息都会到这个队列  
    channel.QueueBind(queue: queueName,
                      exchange: "logs",
                      routingKey: "");

    var consumer = new EventingBasicConsumer(channel);
    consumer.Received += (model, ea) =>
    {
        var body = ea.Body.ToArray();
        var message = Encoding.UTF8.GetString(body);
        Console.WriteLine(" [x] Received '{0}'", message);
    };
    channel.BasicConsume(queue: queueName,
                         autoAck: true,
                         consumer: consumer); 
}
```

 
### **路由（基于路由键）**
在RabbitMQ中，路由（Routing）模式允许生产者发送消息时附带一个路由键（Routing Key），消费者从绑定到特定路由键的队列中接收消息。以下是一个基于路由键的RabbitMQ路由模式的生产者和消费者示例代码，以及字段备注。
生产端
```csharp
using RabbitMQ.Client;
using System.Text;

var factory = new ConnectionFactory() { HostName = "localhost" }; // RabbitMQ服务器地址  
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 声明一个名为"direct_logs"的direct类型的交换器  
    channel.ExchangeDeclare(exchange: "direct_logs", type: "direct");

    // 定义路由键和消息  
    string routingKey = "severe"; // 路由键，用于决定消息发送到哪个队列  
    string message = "This is a severe log message."; // 消息内容  
    var body = Encoding.UTF8.GetBytes(message);

    // 发送消息到交换器，并指定路由键  
    channel.BasicPublish(exchange: "direct_logs",
                         routingKey: routingKey,
                         basicProperties: null,
                         body: body);

    Console.WriteLine(" [x] Sent '{0}' with routing key '{1}'", message, routingKey);
}

```
消费端：
```csharp
using RabbitMQ.Client.Events;
using RabbitMQ.Client;
using System.Text;


var factory = new ConnectionFactory() { HostName = "localhost" };
var queueName =  "consumer_queue"; // 队列名，可以通过命令行参数指定  
var routingKey = "severe"; // 路由键，可以通过命令行参数指定  

using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 声明一个队列（如果需要持久化或特殊配置，可以在这里指定）  
    channel.QueueDeclare(queue: queueName,
                         durable: false,
                         exclusive: false,
                         autoDelete: false,
                         arguments: null);

    // 声明一个名为"direct_logs"的direct类型的交换器  
    channel.ExchangeDeclare(exchange: "direct_logs", type: "direct");

    // 将队列绑定到交换器上，并指定路由键  
    channel.QueueBind(queue: queueName,
                      exchange: "direct_logs",
                      routingKey: routingKey);

    Console.WriteLine(" [*] Waiting for logs. To exit press CTRL+C");

    var consumer = new EventingBasicConsumer(channel);
    consumer.Received += (model, ea) =>
    {
        var body = ea.Body.ToArray();
        var message = Encoding.UTF8.GetString(body);
        Console.WriteLine(" [x] Received '{0}'", message);
    };
    channel.BasicConsume(queue: queueName,
                         autoAck: true,
                         consumer: consumer); 
}

```
## 响应缓存
```csharp
[ResponseCache(Duration = 60, Location = ResponseCacheLocation.Client)]
public IActionResult GetCachedData()
{
    return Content("This is cached data.");
}

```



